# more TODO:
# Import video inside pyqt by frame                             check
# sort csv file by enter time/confi, filter csv by checkbox     check
# add option for user to choose model type / model weight.    check
# time changes when drag the video progres bar.                check
# Export button to renew csv file will edit inside the pyqt app.        check
# add button aloud user to take screenshot for the keyframe of the video.     check
# aloud user get a uoi to start data processing.
#
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'truckana.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import sys
import subprocess
import cv2
import os
import csv
import datetime
import warnings
from pathlib import Path
from typing import List, Tuple
from PyQt5.QtWidgets import QTableWidgetItem, QFileDialog, QLabel
from PyQt5.QtGui import QImage, QPixmap
from PyQt5.QtCore import Qt, QTimer
from PyQt5 import QtWidgets, QtCore

from src.ModelSelectUI import showModelSel
from src.process_video import process
from src.model_registry import ModelRegistry
from config import ROOT_DIR


class Ui_TruckAnalytics(object):
    def setupUi(self, TruckAnalytics):
        TruckAnalytics.setObjectName("TruckAnalytics")
        TruckAnalytics.resize(1242, 789)
        self.centralwidget = QtWidgets.QWidget(TruckAnalytics)
        self.centralwidget.setObjectName("centralwidget")

        # state for started processes
        self.processes: List[subprocess.Popen] = []

        self.timer = QTimer()
        self.timer.timeout.connect(self.check_processes)

        # Setup slider
        self.Slider = QtWidgets.QSlider(self.centralwidget)
        self.Slider.setGeometry(QtCore.QRect(20, 430, 541, 22))
        self.Slider.setOrientation(QtCore.Qt.Horizontal)

        # Setup Export under checkboxes
        self.Export = QtWidgets.QPushButton("Export", self.centralwidget)
        self.Export.setGeometry(QtCore.QRect(1110, 580, 121, 31))
        self.Export.clicked.connect(self.UpdateCsv)

        self.Clearall = QtWidgets.QPushButton("Clear/Set_all", self.centralwidget)
        self.Clearall.setGeometry(QtCore.QRect(1110, 500, 121, 31))
        self.Clearall.clicked.connect(self.clear_checkbox)

        self.Deleterow = QtWidgets.QPushButton("Delete_row", self.centralwidget)
        self.Deleterow.setGeometry(QtCore.QRect(1110, 540, 121, 31))
        self.Deleterow.clicked.connect(self.deleteRow)

        # Setup timeEdit for video display
        self.timeEdit = QtWidgets.QLabel("Time: 00:00:00", self.centralwidget)
        self.timeEdit.setGeometry(QtCore.QRect(440, 460, 118, 22))

        # Set up for processTable
        self.ProcessTable = QtWidgets.QTableWidget(self.centralwidget)
        self.ProcessTable.setGeometry(QtCore.QRect(20, 550, 451, 121))

        # Set up for tableW
        self.tableW = QtWidgets.QTableWidget(self.centralwidget)
        self.tableW.setGeometry(QtCore.QRect(590, 50, 501, 681))
        self.tableW.setColumnCount(20)
        self.tableW.selectionModel().selectionChanged.connect(self.csv_video_connect)

        self.videoplayer = QtWidgets.QLabel("Video player", self.centralwidget)
        self.videoplayer.setGeometry(QtCore.QRect(30, 60, 531, 371))
        self.CarCount = QtWidgets.QLabel("Car Count: 0", self.centralwidget)
        self.CarCount.setGeometry(QtCore.QRect(440, 690, 171, 31))

        # Start setup check boxes
        self.verticalLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget.setGeometry(QtCore.QRect(1110, 50, 121, 431))
        self.Checkbox_layout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
        self.Checkbox_layout.setContentsMargins(0, 0, 0, 0)

        self.checkBoxes = []
        self.lt = QtWidgets.QCheckBox("LT", self.verticalLayoutWidget)
        self.Checkbox_layout.addWidget(self.lt)
        self.lt.stateChanged.connect(self.filter_data)

        self.tronly = QtWidgets.QCheckBox("TrOnly", self.verticalLayoutWidget)
        self.Checkbox_layout.addWidget(self.tronly)
        self.tronly.stateChanged.connect(self.filter_data)

        self.trchass = QtWidgets.QCheckBox("TrChass", self.verticalLayoutWidget)
        self.Checkbox_layout.addWidget(self.trchass)
        self.trchass.stateChanged.connect(self.filter_data)

        self.trflat = QtWidgets.QCheckBox("TrFlat", self.verticalLayoutWidget)
        self.Checkbox_layout.addWidget(self.trflat)
        self.trflat.stateChanged.connect(self.filter_data)

        self.trtrail = QtWidgets.QCheckBox("TrTrail", self.verticalLayoutWidget)
        self.Checkbox_layout.addWidget(self.trtrail)
        self.trtrail.stateChanged.connect(self.filter_data)

        self.trcont = QtWidgets.QCheckBox("TrContainer", self.verticalLayoutWidget)
        self.Checkbox_layout.addWidget(self.trcont)
        self.trcont.stateChanged.connect(self.filter_data)

        self.trtank = QtWidgets.QCheckBox("TrTank", self.verticalLayoutWidget)
        self.Checkbox_layout.addWidget(self.trtank)
        self.trtank.stateChanged.connect(self.filter_data)

        self.Const = QtWidgets.QCheckBox("Const", self.verticalLayoutWidget)
        self.Checkbox_layout.addWidget(self.Const)
        self.Const.stateChanged.connect(self.filter_data)

        self.waste = QtWidgets.QCheckBox("Waste", self.verticalLayoutWidget)
        self.Checkbox_layout.addWidget(self.waste)
        self.waste.stateChanged.connect(self.filter_data)

        self.o = QtWidgets.QCheckBox("O", self.verticalLayoutWidget)
        self.Checkbox_layout.addWidget(self.o)
        self.o.stateChanged.connect(self.filter_data)

        self.vp = QtWidgets.QCheckBox("VP", self.verticalLayoutWidget)
        self.Checkbox_layout.addWidget(self.vp)
        self.vp.stateChanged.connect(self.filter_data)

        self.bus = QtWidgets.QCheckBox("Bus", self.verticalLayoutWidget)
        self.Checkbox_layout.addWidget(self.bus)
        self.bus.stateChanged.connect(self.filter_data)

        self.trreefer = QtWidgets.QCheckBox("TrReefer", self.verticalLayoutWidget)
        self.Checkbox_layout.addWidget(self.trreefer)
        self.trreefer.stateChanged.connect(self.filter_data)

        self.rvc = QtWidgets.QCheckBox("RV/Camper", self.verticalLayoutWidget)
        self.Checkbox_layout.addWidget(self.rvc)
        self.rvc.stateChanged.connect(self.filter_data)

        self.sv = QtWidgets.QCheckBox("SmallVehicle", self.verticalLayoutWidget)
        self.Checkbox_layout.addWidget(self.sv)
        self.sv.stateChanged.connect(self.filter_data)

        self.checkBoxes.extend(
            [
                self.lt,
                self.tronly,
                self.trchass,
                self.trflat,
                self.sv,
                self.trtrail,
                self.trcont,
                self.rvc,
                self.trtank,
                self.Const,
                self.waste,
                self.o,
                self.vp,
                self.bus,
                self.trreefer,
            ]
        )

        # Setup button for playpause buttons
        self.PlayPauseLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.PlayPauseLayoutWidget.setGeometry(QtCore.QRect(20, 440, 295, 100))
        self.PlayPause_layout = QtWidgets.QHBoxLayout(self.PlayPauseLayoutWidget)
        self.PlayPause_layout.setContentsMargins(0, 0, 0, 0)
        self.back = QtWidgets.QPushButton("<<", self.PlayPauseLayoutWidget)
        self.back.clicked.connect(self.GoBack)
        self.PlayPause_layout.addWidget(self.back)
        self.play = QtWidgets.QPushButton("Play/Pause", self.PlayPauseLayoutWidget)
        self.play.clicked.connect(self.pausevideo)
        self.PlayPause_layout.addWidget(self.play)
        self.foward = QtWidgets.QPushButton(">>", self.PlayPauseLayoutWidget)
        self.foward.clicked.connect(self.SkipFront)
        self.PlayPause_layout.addWidget(self.foward)

        self.ScreenShot = QtWidgets.QPushButton("Shot", self.PlayPauseLayoutWidget)
        self.ScreenShot.clicked.connect(self.Take_SCS)
        self.ScreenShot.setGeometry(QtCore.QRect(0, 70, 121, 31))

        self.ProExplLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.ProExplLayoutWidget.setGeometry(QtCore.QRect(10, -10, 201, 80))
        self.Pro_Exp_layout = QtWidgets.QHBoxLayout(self.ProExplLayoutWidget)
        self.Pro_Exp_layout.setContentsMargins(0, 0, 0, 0)
        self.process = QtWidgets.QPushButton("Process", self.ProExplLayoutWidget)
        self.Pro_Exp_layout.addWidget(self.process)
        self.process.clicked.connect(self.Process_Video)
        self.explore = QtWidgets.QPushButton("Explore", self.ProExplLayoutWidget)
        self.Pro_Exp_layout.addWidget(self.explore)
        self.explore.clicked.connect(self.load_data)

        # Below are setup for menueBar
        TruckAnalytics.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(TruckAnalytics)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1242, 26))
        self.menubar.setObjectName("menubar")
        self.menusort_by = QtWidgets.QMenu("sort by", self.menubar)
        TruckAnalytics.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(TruckAnalytics)
        TruckAnalytics.setStatusBar(self.statusbar)
        self.actiontime = QtWidgets.QAction(TruckAnalytics)
        self.actiontime.triggered.connect(self.SortbyTime)
        self.actionConfi = QtWidgets.QAction(TruckAnalytics)
        self.actionConfi.triggered.connect(self.SortbyConfi)
        self.menusort_by.addAction(self.actiontime)
        self.menusort_by.addAction(self.actionConfi)
        self.menubar.addAction(self.menusort_by.menuAction())

        self.retranslateUi(TruckAnalytics)
        QtCore.QMetaObject.connectSlotsByName(TruckAnalytics)
        self.video_capture = None
        self.total_frames = 0
        self.image_label = QLabel(self.centralwidget)

        self.video_timer = QTimer()
        self.video_timer.timeout.connect(self.update_frame)
        self.video_timer.start(
            30
        )  # Set the frame update rate in milliseconds (e.g., 30fps)

        self.playState = 0  # 0:stop, 1:play, 2:pause
        self.program = ""  # video that about to play
        self.currentProg = ""  # video that's playing for now
        self.current_frame = 0
        self.debug = 1
        self.lastFrame = None  # use to check last frame
        self.filepath2 = None
        self.HeaderLable = None

    def check_processes(self):
        finished_processes = []
        for process in self.processes:
            if process.poll() is not None:
                finished_processes.append(process)

        for process in finished_processes:
            self.processes.remove(process)
            ret = process.communicate()  # Clean up process resources

        if not self.processes:
            self.timer.stop()

        # update process table (idk why but if it works it works)
        self.display_processTabW(self.processes)

    def retranslateUi(self, TruckAnalytics):
        _translate = QtCore.QCoreApplication.translate
        TruckAnalytics.setWindowTitle(_translate("TruckAnalytics", "MainWindow"))
        self.actiontime.setText(_translate("TruckAnalytics", "time"))
        self.actionConfi.setText(_translate("TruckAnalytics", "Confidence"))

    def GoBack(self):
        # Rewind video for 30 frames.
        current_frame = int(self.video_capture.get(cv2.CAP_PROP_POS_FRAMES))
        target_frame = max(0, current_frame - 30)
        self.video_capture.set(cv2.CAP_PROP_POS_FRAMES, target_frame)

    def pausevideo(self):
        # this function is use to determine the state of the videoplayer
        if self.playState == 0:
            self.playState = 1
        elif self.playState == 1:
            self.playState = 2
        elif self.playState == 2:
            self.playState = 1
        return

    def SkipFront(self):
        # Skip video for 30 frames.
        current_frame = int(self.video_capture.get(cv2.CAP_PROP_POS_FRAMES))
        target_frame = max(0, current_frame + 30)
        self.video_capture.set(cv2.CAP_PROP_POS_FRAMES, target_frame)

    def Take_SCS(self):
        # This function is use to let user take screenshot. and save it to the selected file.
        Current_FN = int(self.video_capture.get(cv2.CAP_PROP_POS_FRAMES))
        output_folder = QFileDialog.getExistingDirectory(None)

        # Check if a folder was selected or if the dialog was cancelled
        if output_folder:
            frame_filename = os.path.join(output_folder, f"{Current_FN:04d}.jpg")
            _, frame = self.video_capture.read()
            cv2.imwrite(frame_filename, frame)
            print(f"Frame {Current_FN} saved as {frame_filename}")
        else:
            print("Screenshot save operation cancelled.")

    def Process_Video(self):
        # This button is use for process a new video.
        # 1) select a new mp4 video
        # 2ï¼‰jump to model selection page and do selection.

        # user selected video path
        video_path, _ = QFileDialog.getOpenFileName(None)
        if not video_path.endswith(".mp4"):
            warnings.warn("invalid file for processing, must be an mp4 file")
            return None

        modelJson = showModelSel()
        if modelJson is None:
            # user exited the model selection page without confirming
            return None

        model_folder = modelJson.get("model", None)
        if model_folder is not None:
            # get process video arguments ready
            active_learn = modelJson.get("active_learn", False)
            active_learning_classes = ["trreefer", "vp"]
            active_learning_budget = 25
            abs_vid_path = str(Path(video_path).resolve())
            python_path = sys.executable
            process_script = str(Path(__file__).parent / "process_video.py")

            command = [
                python_path,
                process_script,
                abs_vid_path,
                "--model",
                model_folder,
                "--active-learning-classes",
                *active_learning_classes,
                "--active-learning-budget",
                str(active_learning_budget),
            ]
            if active_learn:
                command.append("--active-learn")

            if not self.processes:
                # timer for polling finished processes
                self.timer.start(5000)

            self.processes.append(
                subprocess.Popen(args=command, stdout=subprocess.DEVNULL)
            )
            self.display_processTabW(self.processes)
        else:
            warnings.warn("No detector selected, cannot continue to processing")
            return None

    def load_data(self):
        # upload correct type of document
        # if document type is mp4, then process it as a video.
        # if document type is csv, then process it as a csv file.
        # Other document type will raise an error.
        filepath2, _ = QFileDialog.getOpenFileName(None)
        filename = os.path.basename(filepath2)  # find the file name
        if filename.endswith(
            ".csv"
        ):  # If the loaded data is a csv file, then process it as a csv.
            # print("This is a csv file")
            self.filepath2 = filepath2
            with open(filepath2, "r") as file:
                self.data = list(csv.reader(file))  # if file != *.csv  raise Exception
            self.HeaderLable = self.data.pop(0)
            self.tableW.setHorizontalHeaderLabels(
                self.HeaderLable
            )  # Set header with using 1st row of csv
            self.load_data_to_table()

        elif filename.endswith(
            ".mp4"
        ):  # if the loaded data is a mp4 videl, then process it as a mp4 video.
            # print("This is a mp4 video.")
            self.program = filepath2
            self.video_capture = cv2.VideoCapture(filepath2)
            self.total_frames = int(self.video_capture.get(cv2.CAP_PROP_FRAME_COUNT))
            self.fps = int(self.video_capture.get(cv2.CAP_PROP_FPS))
            self.Slider.setRange(0, self.total_frames - 1)
            self.Slider.sliderMoved.connect(self.set_position)

        else:
            raise Exception("Sorry, Wrong type of data!")

    def format_time(self, time_in_seconds):
        m, s = divmod(time_in_seconds, 60)
        h, m = divmod(m, 60)
        return f"{int(h):02}:{int(m):02}:{int(s):02}"

    def __startProg(self):
        if os.path.isfile(self.program):
            self.video_capture = cv2.VideoCapture(self.program)
            if self.video_capture:
                self.currentProg = self.program
                self.total_frames = int(
                    self.video_capture.get(cv2.CAP_PROP_FRAME_COUNT)
                )
                self.Slider.setRange(0, self.total_frames - 1)
                self.current_frame = 0
                self.Slider.setValue(0)
                return True  # play normally
            else:
                if self.debug:
                    print(self.program, " open fail!")
                return False  # file can't read
        else:
            if self.debug:
                print(self.program, " is not exist!")
            return False  # file not exist

    def __flashFrame(self, frame):
        # Convert the frame to RGB format
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        # Convert the frame to QImage
        height, width, channel = frame_rgb.shape
        q_image = QImage(
            frame_rgb.data, width, height, width * channel, QImage.Format_RGB888
        )
        # Convert QImage to QPixmap
        pixmap = QPixmap.fromImage(q_image)
        # Scale the QPixmap to fit the QLabel
        scaled_pixmap = pixmap.scaled(
            self.videoplayer.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation
        )
        # Display the frame in the QLabel
        # self.image_label.setPixmap(scaled_pixmap)
        self.videoplayer.setPixmap(scaled_pixmap)
        # Update the slider position
        self.current_frame = int(self.video_capture.get(cv2.CAP_PROP_POS_FRAMES))
        self.Slider.setValue(self.current_frame)

    def update_frame(self):
        if self.debug:
            self.debug = self.debug + 1

        if self.playState == 0:
            self.video_capture = None
            self.current_frame = 0
            return
        elif self.playState == 1:
            if self.video_capture:
                # playState ==1 and self.video_capture !=None
                self.program = self.program.strip().lower()
                self.currentProg = self.currentProg.strip().lower()
                if self.currentProg not in self.program:
                    if self.__startProg() == False:
                        self.playState = 0
                        return
            elif self.__startProg() == False:
                self.playState = 0
                return
                # playState ==1 and self.video_capture ==None
        elif self.playState == 2:
            if self.video_capture == None:
                self.playState = 0
                return
            elif self.lastFrame is not None:
                self.__flashFrame(self.lastFrame)
                return
        else:
            if self.debug:
                print("unsure state. reset to 0")
            self.playState = 0
            return
        #####Normal########
        if self.debug:
            if self.debug % 30 == 0:
                print(f"playing......{self.currentProg} ")
        ret, frame = self.video_capture.read()
        if ret:
            self.__flashFrame(frame)
            self.lastFrame = frame

        current_frame = int(self.video_capture.get(cv2.CAP_PROP_POS_FRAMES))
        elapsed_time = current_frame / self.fps
        total_time = self.total_frames / self.fps
        self.timeEdit.setText(
            f"Time: {self.format_time(elapsed_time)} / {self.format_time(total_time)}"
        )

    def set_position(self, value):
        # set slider positon
        self.video_capture.set(cv2.CAP_PROP_POS_FRAMES, value)

    def closeEvent(self, event):
        self.video_capture.release()
        self.video_timer.stop()
        event.accept()

    def load_data_to_table(self):
        self.tableW.setColumnCount(len(self.data[0]))
        self.tableW.setRowCount(len(self.data))
        for row_idx, row_data in enumerate(self.data):
            for col_idx, col_data in enumerate(row_data):
                item = QTableWidgetItem(col_data)
                self.tableW.setItem(row_idx, col_idx, item)
        self.CarCount.setText(f"Total Count: {self.tableW.rowCount()}")
        # Set all checkbox to True
        for checkboxes in self.checkBoxes:
            checkboxes.setChecked(True)
        self.isboxchecked = True  # True means all box is checked.

    def filter_data(self):
        show_LT = self.lt.isChecked()
        show_Tronly = self.tronly.isChecked()
        show_TrChass = self.trchass.isChecked()
        show_TrFlat = self.trflat.isChecked()
        show_Trtrail = self.trtrail.isChecked()
        show_Trcont = self.trcont.isChecked()
        show_TrTank = self.trtank.isChecked()
        show_Const = self.Const.isChecked()
        show_Waste = self.waste.isChecked()
        show_O = self.o.isChecked()
        show_VP = self.vp.isChecked()
        show_Trreefer = self.trreefer.isChecked()
        show_bus = self.bus.isChecked()
        show_RVC = self.rvc.isChecked()
        show_SV = self.sv.isChecked()
        NewRowcount = self.tableW.rowCount()

        col_count = self.HeaderLable.index("class")
        for row in range(self.tableW.rowCount()):
            category = self.data[row][col_count].lower()
            if (
                (category == "lt" and not show_LT)
                or (category == "trcont" and not show_Trcont)
                or (category == "const" and not show_Const)
            ):
                self.tableW.setRowHidden(row, True)
                NewRowcount -= 1
            elif (
                (category == "tronly" and not show_Tronly)
                or (category == "trchass" and not show_TrChass)
                or (category == "trflat" and not show_TrFlat)
            ):
                self.tableW.setRowHidden(row, True)
                NewRowcount -= 1
            elif (
                (category == "trtrail" and not show_Trtrail)
                or (category == "vp" and not show_VP)
                or (category == "bus" and not show_bus)
            ):
                self.tableW.setRowHidden(row, True)
                NewRowcount -= 1
            elif (
                (category == "trtank" and not show_TrTank)
                or (category == "waste" and not show_Waste)
                or (category == "o" and not show_O)
                or (category == "trreefer" and not show_Trreefer)
            ):
                self.tableW.setRowHidden(row, True)
                NewRowcount -= 1
            elif (category == "rvc" and not show_RVC) or (
                category == "sv" and not show_SV
            ):
                self.tableW.setRowHidden(row, True)
                NewRowcount -= 1
            else:
                self.tableW.setRowHidden(row, False)
        self.CarCount.setText(f"Total Count: {NewRowcount}")

    def SortbyConfi(self):
        # sort self.data by Confidence // second col of data
        try:
            col_num = self.HeaderLable.index("confidence")
            print(self.data)
            self.data.sort(key=lambda x: float(x[col_num]), reverse=True)
            self.load_data_to_table()
        except AttributeError as err:
            print("Can't sort when here is no data!")

    def SortbyTime(self):
        # sort self.data by time // third col of data
        try:
            col_num = self.HeaderLable.index("initial_frame_index")
            self.data.sort(key=lambda x: float(x[col_num]))
            self.load_data_to_table()
        except AttributeError as err:
            print("Can't sort when here is no data!")

    def clear_checkbox(self):
        # Change state of checkboxes
        try:
            if self.isboxchecked:
                for checkboxes in self.checkBoxes:
                    checkboxes.setChecked(False)
                self.isboxchecked = False
            elif self.isboxchecked is False:
                for checkboxes in self.checkBoxes:
                    checkboxes.setChecked(True)
                self.isboxchecked = True
        except AttributeError as err:
            print("Can't change checkbox state when there is no data.")

    def UpdateCsv(self):
        # this function is use for update csv after the data been changed from the interface.
        try:
            # row = self.tableW.currentRow()
            # col = self.tableW.currentColumn()
            # message = self.tableW.item(row, col).text()
            # here re-read every row from the table and write them into the csv file.
            with open(self.filepath2, "w", newline="") as file:
                writer = csv.writer(file)
                writer.writerow(self.HeaderLable)
                for row in range(self.tableW.rowCount()):
                    row_data = []
                    for col in range(self.tableW.columnCount()):
                        item = self.tableW.item(row, col)
                        if item is not None:
                            row_data.append(item.text())
                        else:
                            row_data.append("")
                    writer.writerow(row_data)

            print("CSV file updated successfully.")
        except Exception as e:
            print("Error:", e)

    def deleteRow(self):
        # delete the selected row.
        row = self.tableW.currentRow()
        self.tableW.removeRow(row)

    def csv_video_connect(self):
        # change the position of the video player base of frame count from the csv file
        row = self.tableW.currentRow()
        col_num = self.HeaderLable.index("initial_frame")
        message = self.tableW.item(
            row, col_num
        ).text()  # Message is the frame count from the csv.

        self.video_capture.set(cv2.CAP_PROP_POS_FRAMES, int(message))
        ret, frame = self.video_capture.read()
        if ret:
            frame_rgb = cv2.cvtColor(
                frame, cv2.COLOR_BGR2RGB
            )  # Convert frame to RGB format
            image = QImage(
                frame_rgb.data,
                frame_rgb.shape[1],
                frame_rgb.shape[0],
                QImage.Format_RGB888,
            )
            pixmap = QPixmap.fromImage(image)
            self.videoplayer.setPixmap(pixmap)

    def display_processTabW(self, processes):
        # this is use to display processtableWidget.
        self.ProcessTable.setRowCount(len(processes))
        self.ProcessTable.setColumnCount(2)
        for row, process in enumerate(processes):
            button = QtWidgets.QPushButton("KILL")
            button.clicked.connect(lambda checked, r=row: self.Kill_process(r))
            self.ProcessTable.setCellWidget(row, 1, button)
            self.ProcessTable.setColumnWidth(0, 300)

            vid_name = Path(process.args[2]).name
            item = QTableWidgetItem(vid_name)
            self.ProcessTable.setItem(row, 0, item)
            self.ProcessTable.setColumnWidth(1, 100)

    def Kill_process(self, row):
        if row < len(self.processes):
            process = self.processes[row]
            process.terminate()  # Terminate the process
            self.processes.pop(row)
            self.ProcessTable.removeRow(row)
        return row


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    TruckAnalytics = QtWidgets.QMainWindow()
    ui = Ui_TruckAnalytics()
    ui.setupUi(TruckAnalytics)
    TruckAnalytics.show()
    sys.exit(app.exec_())
